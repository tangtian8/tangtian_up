# java虚拟机

## 程序编译与代码优化

### 前端编译与优化

前端编译：把.java 文件转变成.class文件的过程

前端编译器：JDK的javac、Eclipse JDT 中的增量式编译器



### Javac编译器

阅读javac代码：编译过程分为1个准备过程和3个处理过程

1. 准备过程：初始化插入式注解处理器
2. 解析与填充符号表过程
   1. 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树
   2. 填充符号表。产生符号地址和符号信息
3. 插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段
4. 分析与字节码生成过程
   1. 标注检查。对语法的静态信息进行检查
   2. 数据流及控制流分析。对程序动态运行过程进行检查
   3. 解语法糖。将简化代码编写的语法糖还原为原有的形式
   4. 字节码生成。将前面各个步骤生成的信息转换为字节码，生成最终的class文件

![](https://www.jingqueyimu.com/upload/2020/03/22/Javac%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B-07331843.jpg)

【经典程序编译原理步骤词法分析、语法分析】

词法分析：将源代码的字符流转变为标记（TOKEN）集合的过程

1. 单个字符是程序编写的最小元素、标记是编译时的最小元素。关键字、变量名、字面量、运算符可以作为标记

语法分析：根据标记序列构造抽象语法树的过程。抽象语法数是一种用来描述程序代码语法结构的树形表示方式

填充符号表：

### java语法糖的味道

泛型：泛型的本质是参数化类型，或者参数化多态。即：可以将操作的数据类型指定为方法签名中的一种特殊参数。这种参数可以在类，接口和方法的创建中，分别构成泛型类，泛型接口，泛型方法。

Java与C#的泛型

1. JAVA的泛型叫做“类型擦除式泛型”：java 的泛型只在源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型。
   1. 裸类型：所有该类型泛型化实例的共同父类型。  
2. c#的泛型的实现方式“具现化式泛型”：无论在程序的源码里面，编译后的中间语音里面，或者是运行期的CLR里面都是切实存在的

```java
public class TypeErasureGenerics<E>{
    public void doSomething(Object item){
        if(item instanceof E){ //不合法，无法对泛型进行实例判断
            
        }
        E newItem = new E();//不合法，无法使用泛型创建对象
        E[] itemArray = new E[10];//不合法，无法使用泛型创建数组
    }
}
```

二进制向后兼容

值类型：

语法糖：自动装箱、自动拆箱与遍历循环

语法糖：条件编译

语法糖：内部类、枚举类、断言语句、数值字面量、对枚举和字符串switch支持、try语句中定义和关闭资源、Lambda表达式

包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱、以及它们equals()方法不处理数据类型转换的关系



## 垃圾收集器与内存分配策略

### 引用计数算法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一。当引用失效时，计数器值就减一，任何时刻计数器为零的对象就是不可能在被使用的；



相互引用， 引用计数都不为零。无法回收。

```java
public class ReferenceCountingGC{
    public Object instance = null;
    private static final int _1MB = 1024*1024;
    //便于观察GC回收
    private byte[] bigSize = new byte[2 * _1MB];
    
    public static void testGC(){
        ReferenceCountGC ObjA = new ReferenceCountingGC();
        ReferenceCountGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        
        objA = null;
        objB = null;
        
        system.gc();
    }
}
```

### 可达性分析算法

经历两次标记过程：

如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链。那将会被第一次标记

finalize()方法是对象逃脱死亡命运的最后一次机会，收集器将对F-Queue中的对象进行第二次小规模的标记。

回收方法区：

CMS基于增量更新作为并发标记

G1、Shenandoah原始快照作为并发标记 

### 垃圾收集算法

引用计数式垃圾收集：直接垃圾收集

追踪式垃圾收集：间接垃圾收集

 分代收集并非是划分内存区域那么容易，至少存在一个明显的困难。对象不是孤立的，对象之间会存在跨代引用。 



#### 标记-清除算法

主要缺点：

1. 执行效率不稳定，
2. 内存空间碎片化

#### 标记-复制算法

1. 为了解决标记-清除算法面对大量可回收对象时执行效率低的问题
2. 半复制区：hotSpot虚拟机默认Edge和Survivor的大小比例是8：1
3. 对象存活率较高时候就要进行较多的复制操作。效率将会降低。

#### 标记-整理算法



### 经典垃圾收集器

#### Serial收集器

单线程工作收集器

1. 优于其他收集器的地方：简单而高效
2. 对于内存资源受限的情况：额外内存消耗最小的
3. 没有线程交互开销

#### ParNew收集器

Serial收集器的多线程并行版本

#### Parallel Scavenge收集器

1. 标记-复制算法
2. 并行收集
3. 目标是达到可控制的吞吐量
4. 吞吐量 = 运行用户代码时间/运行用户代码时间+运行垃圾收集时间

#### Serial Old 收集器

1. 标记-整理
2. 

#### Parallel Old 收集器

1. 标记-整理

#### CMS收集器

1. 获取最短回收停顿时间为目标的收集器
2. 并发低停顿
3. 标记-清除
4. 过程
   1. 初始标记：标记一下GC ROOTs能之间关联到的对象
   2. 并发标记：GC Roots的直接关联对象开始遍历整个对象图
   3. 重新标记：并发标记期间产生的记录
   4. 并发清除
5. 初始标记、重新标记仍然需要“stop the world”
6. 缺点
   1. 对处理器的资源非常敏感，占用了一部分线程导致应用程序变慢，降低吞吐量。
   2. CMS收集器无法处理浮动垃圾：并发标记、并发清理产生的垃圾
   3. 基于标记-清除，产生大量的空间碎片
   

#### Garbage First 收集器

1. 面向堆内存任何部分来组成回收集，衡量标准不是它属于哪个分代，而是哪块内存存放的垃圾数量最多，回收收益最大，G1收集器的Mixed GC 模式。
2. 基于Region的堆内存布局
3. 把连续的Java堆划分为多个大小相等的独立区域
4. 关注的问题
   1. Region存在跨Region引用对象如何解决：使用记忆集避免全堆作为GCRoots扫描
   2. 收集线程与用户线程互不干扰的运行：原始快照
   3. 建立可靠的停顿预测模型
5. 运作过程
   1. 初始标记
   2. 并发标记
   3. 最终标记
   4. 筛选回收
6. 延迟可控的情况下获得尽可能高的吞吐量
7. 可以设定允许的收集停顿时间（使用参数-XX:MaxGCPauseMillis，默认值是200毫秒），优先处理回收价值收益最大的Region。（Garbage First名字由来）
8. 运行期间不会产生空间内存碎片 
9. 缺点
   1. G1和CMS都使用卡表来处理跨代指针
   2. G1的记忆集可能会占整个堆容量的20%或者更多的内存空间
10. 小内存CMS的表现大概率要优于G1

#### 低延迟垃圾收集器

1. 衡量垃圾收集器的三项重要指标：内存占用、吞吐量、延迟
2. 延迟称为垃圾收集器最被重视的性能指标

#### Shenandoah收集器

#### ZGC收集器

#### PGC收集器

#### c4收集器

#### Epsilon收集器

### 选择合适的垃圾回收器

1. 应用程序主要关注点是什么
   1. 数据分析、科学计算。目标是尽快算出来。吞吐量是主要关注点。
   2. SLA应用、停顿时间直接影响服务质量、导致事务的超时，延迟就是主要关注点
   3. 客户端应用或者是嵌入式应用、垃圾收集内存占用是不可忽略的
2. 运行应用的基础设施
   1. 系统架构
   2. 处理器数量、分配内存的大小
   3. 操作系统
3. JDK的发行商是什么？版本号是多少？JDK对应了《Java虚拟机规范》的哪个版本

### 内存分配与回收策略

#### 对象优先在Eden分配

#### 大对象直接进入老年代

#### 长期存活的对象将进入老年代

####  动态对象年龄判定

#### 空间分配担保
